package com.epitech.diabetips.services

import android.app.Activity
import android.app.PendingIntent
import android.content.Context
import android.content.Context.VIBRATOR_SERVICE
import android.content.Intent
import android.content.IntentFilter
import android.nfc.NfcAdapter
import android.nfc.Tag
import android.nfc.tech.NfcV
import android.os.AsyncTask
import android.os.Looper
import android.os.Vibrator
import android.util.Log
import android.widget.TextView
import android.widget.Toast
import com.epitech.diabetips.R
import com.epitech.diabetips.freestylelibre.GlucoseData
import com.epitech.diabetips.freestylelibre.RawTagData
import com.epitech.diabetips.freestylelibre.SensorData
import com.epitech.diabetips.storages.BloodSugarObject
import com.epitech.diabetips.utils.RequestCode
import com.epitech.diabetips.utils.TimeHandler
import java.io.*
import java.util.*
import kotlin.experimental.and
import kotlin.random.Random

var NFC_USE_MULTI_BLOCK_READ = true

@Suppress("DEPRECATION") class NfcReaderService(var context: Context, myIntent: Intent, var activity: Activity, private val GlucoseUpdated: () -> Unit) {
    val MIME_TEXT_PLAIN = "text/plain"

    private var mNfcAdapter: NfcAdapter? = null


    var lectura: String? = null
    private var buffer: kotlin.String? = null
    private var currentGlucose = 0f
    private val tvResult: TextView? = null
    private val last: TextView? = null
    var numHistoryValues = 32
    var historyIntervalInMinutes = 15
    var numTrendValues = 16
    var minSensorAgeInMinutes: Long = 60 // data generated by the sensor in the first 60 minutes is not correct
    var nfcStatus = ""
    var isNfcOn = false

    private var data: ByteArray = ByteArray(360)
//    private val onDataReceived : ((RecipeObject) -> Unit)? = null


    init {
        mNfcAdapter = NfcAdapter.getDefaultAdapter(context)
        updateNfcStatus(true)
        handleIntent(myIntent)
        var glucoseDatas = ArrayList<GlucoseData>()
        try {
            val fos: FileOutputStream = context.applicationContext.openFileOutput(
                "glucose",
                Context.MODE_PRIVATE
            )
            fos.close()
            val fis: FileInputStream = context.applicationContext.openFileInput("glucose")
            val ois = ObjectInputStream(fis)
            glucoseDatas = ArrayList((ois.readObject() as ArrayList<*>).filterIsInstance<GlucoseData>())
            ois.close()
            fis.close()
        } catch (ioe: IOException) {
            ioe.printStackTrace()
        } catch (c: ClassNotFoundException) {
            c.printStackTrace()
        }
        Log.d("Saved data", "$glucoseDatas".trimIndent())
        if (glucoseDatas.size > 1)
            Log.d("Saved Sensor age", "${glucoseDatas[0].ageInSensorMinutes}".trimIndent())
    }

    fun onResume() {
        setupForegroundDispatch(context as Activity, mNfcAdapter)
    }

    fun onPause() {
        stopForegroundDispatch(context as Activity, mNfcAdapter)
    }

    fun onNewIntent(intent: Intent?) {
        /**
         * This method gets called, when a new Intent gets associated with the current activity instance.
         * Instead of creating a new activity, onNewIntent will be called. For more information have a look
         * at the documentation.
         *
         * In our case this method gets called, when the user attaches a Tag to the device.
         */
        Log.d("NfcReaderDiabetips", "NEW INTENT FOUND")
        if (intent != null) {
            handleIntent(intent)
        } else {
            Log.d("NfcReaderDiabetips", "No Intent found")
        }
    }

    private fun handleIntent(intent: Intent) {
        val action = intent.action
        Log.d("Diabetips", "Action FOUND ! ! !")
        if (NfcAdapter.ACTION_TECH_DISCOVERED == action) {
            val fakeDayDataGenerator = FakeDayDataGenerator(10, 100f + Random.nextInt(-10, 10).toFloat(), Random(2));
            val points =  fakeDayDataGenerator.getDay();
            fakeDayDataGenerator.removeData(TimeHandler.instance.currentTime(), context.getString(R.string.format_time_api)).doOnSuccess{
                fakeDayDataGenerator.sendData(points,  TimeHandler.instance.changeTimestampTime(TimeHandler.instance.currentTime(), hour = 0, minute = 0), true, context.getString(R.string.format_time_api)).doOnSuccess {
                    GlucoseUpdated()
                }.subscribe()
            }.subscribe()
            return;
            //Log.d("Diabetips", "NfcAdapter.ACTION_TECH_DISCOVERED")
            // In case we would still use the Tech Discovered Intent
            //val tag = intent.getParcelableExtra<Tag>(NfcAdapter.EXTRA_TAG)
            //val techList = tag?.techList
            //val searchedTech = NfcV::class.java.name
            //NfcVReaderTask().execute(tag)
        }
    }

    /**
     * @param activity The corresponding [Activity] requesting the foreground dispatch.
     * @param adapter The [NfcAdapter] used for the foreground dispatch.
     */
    private fun setupForegroundDispatch(activity: Activity, adapter: NfcAdapter?) {
        val pi: PendingIntent = activity.createPendingResult(RequestCode.NFC_READER.ordinal, Intent(), 0)
        if (updateNfcStatus()) {
            try {
                adapter?.enableForegroundDispatch(
                    activity,
                    pi,
                    arrayOf(IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED)),
                    arrayOf(arrayOf("android.nfc.tech.NfcV"))
                )
            } catch (e: NullPointerException) {
                // Drop NullPointerException
            }
        }
        Log.d("Diabetips", "SETUP ForegroundDispatch")
    }

    /**
     * @param activity The corresponding {BaseActivity} requesting to stop the foreground dispatch.
     * @param adapter The [NfcAdapter] used for the foreground dispatch.
     */
    private fun stopForegroundDispatch(activity: Activity?, adapter: NfcAdapter?) {
        if (isNfcOn) {
            adapter?.disableForegroundDispatch(activity)
        }
    }

    private val LOG_ID = "OpenLibre::${NfcVReaderTask::class.java.simpleName}"
    private val nfcReadTimeout: Long = 1000 // [ms]

    private var sensorTagId: String? = null


    /**
     *
     * Background task for reading the data. Do not block the UI thread while reading.
     *
     */
    private inner class NfcVReaderTask : AsyncTask<Tag?, Void?, String?>() {

        override fun onPostExecute(result: String?) {
            val vibrator = context.getSystemService(VIBRATOR_SERVICE) as Vibrator
            vibrator.vibrate(1000)
            //Abbott.this.finish()
        }

        fun bytesToHexString(src: ByteArray?): String {
            val builder = StringBuilder("")
            if (src == null || src.isEmpty()) {
                return ""
            }
            val buffer = CharArray(2)
            for (b in src) {
                buffer[0] =
                    Character.forDigit(((b.toInt() ushr 4).toByte() and 0x0F.toByte()).toInt(), 16)
                buffer[1] = Character.forDigit((b and 0x0F.toByte()).toInt(), 16)
                builder.append(buffer)
            }
            return builder.toString()
        }


        override fun doInBackground(vararg params: Tag?): String? {
            Looper.prepare()
            val tag = params[0]
            val nfcvTag = NfcV.get(tag)
            sensorTagId = bytesToHexString(tag!!.id)
            readNfcTag(tag)
            val raw = RawTagData(sensorTagId, data)
            val indexHistory = raw.getIndexHistory()
            val glucoseLevels = ArrayList<Int>()
            val ageInSensorMinutesList = ArrayList<Int>()
            val mostRecentHistoryAgeInMinutes: Int =
                3 + (raw.sensorAgeInMinutes - 3) % historyIntervalInMinutes
            val sensor = SensorData(raw)
            val glucoseDatas = ArrayList<GlucoseData>()
            // read history values from ring buffer, starting at indexHistory (bytes 124-315)
            for (counter in 0 until numHistoryValues) {
                val index: Int = (indexHistory + counter) % numHistoryValues
                val glucoseLevelRaw = raw.getHistoryValue(index)
                // skip zero values if the sensor has not filled the ring buffer yet completely
                if (glucoseLevelRaw > 0) {
                    val dataAgeInMinutes: Int =
                        mostRecentHistoryAgeInMinutes + (numHistoryValues - (counter + 1)) * historyIntervalInMinutes
                    val ageInSensorMinutes = raw.sensorAgeInMinutes - dataAgeInMinutes

                    // skip the first hour of sensor data as it is faulty
                    if (ageInSensorMinutes > minSensorAgeInMinutes) {
                        glucoseLevels.add(glucoseLevelRaw)
                        ageInSensorMinutesList.add(ageInSensorMinutes)
                        val glucoseData = GlucoseData(
                            sensor,
                            raw.sensorAgeInMinutes,
                            raw.timezoneOffsetInMinutes,
                            glucoseLevelRaw,
                            true,
                            ageInSensorMinutes.toLong()
                        )
                        glucoseDatas.add(glucoseData)
                    }
                }
            }
            try {
                val fos: FileOutputStream = context.applicationContext.openFileOutput(
                    "glucose",
                    Context.MODE_PRIVATE
                )
                val oos = ObjectOutputStream(fos)
                oos.writeObject(glucoseDatas)
                oos.close()
                fos.close()
            } catch (ioe: IOException) {
                ioe.printStackTrace()
            }
            val bs: BloodSugarObject = BloodSugarObject()
            bs.interval = historyIntervalInMinutes * 60
            if (glucoseDatas.size <= 0) {
                Toast.makeText(context, context.getString(R.string.sensor_not_ready), Toast.LENGTH_SHORT).show()
                return null
            }
            bs.start = TimeHandler.instance.addTimeToFormat(
                TimeHandler.instance.formatTimestamp(sensor.startDate, context.getString(R.string.format_time_api)),
                context.getString(R.string.format_time_api),
                glucoseDatas[0].date.toInt())
            bs.measures = glucoseLevels.map { it -> it / 10 }.toTypedArray()
            Log.d("MEASURES", bs.measures.joinToString(","))
            Log.d("LAST", bs.measures[bs.measures.size - 1].toString())
            Log.d("END", bs.measures[0].toString())

            BloodSugarService.instance.postMeasures(bs).doOnSuccess {
                GlucoseUpdated()
                if (it.second.component2() != null) {
                    Log.d("BLOOD", it.second.component2()!!.exception.message.toString())
                }
            }.subscribe()
            return null
        }
    }

    private fun readNfcTag(tag: Tag): Boolean {
        val nfcvTag = NfcV.get(tag)
        Log.d(LOG_ID, "Attempting to read tag data")
        try {
            nfcvTag.connect()
            val uid = tag.id
            val step = if (NFC_USE_MULTI_BLOCK_READ) 3 else 1
            val blockSize = 8
            var blockIndex = 0
            while (blockIndex <= 40) {
                var cmd: ByteArray
                if (NFC_USE_MULTI_BLOCK_READ) {
                    cmd = byteArrayOf(
                        0x02,
                        0x23,
                        blockIndex.toByte(),
                        0x02
                    ) // multi-block read 3 blocks
                } else {
                    cmd = byteArrayOf(
                        0x60,
                        0x20,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        blockIndex.toByte(),
                        0
                    )
                    System.arraycopy(uid, 0, cmd, 2, 8)
                }
                var readData: ByteArray
                val startReadingTime = System.currentTimeMillis()
                while (true) {
                    try {
                        readData = nfcvTag.transceive(cmd)
                        break
                    } catch (e: IOException) {
                        if (System.currentTimeMillis() > startReadingTime + nfcReadTimeout) {
                            Log.e(LOG_ID, "tag read timeout")
                            return false
                        }
                    }
                }
                if (NFC_USE_MULTI_BLOCK_READ) {
                    System.arraycopy(
                        readData,
                        1,
                        data,
                        blockIndex * blockSize,
                        readData.size - 1
                    )
                } else {
                    readData = Arrays.copyOfRange(readData, 2, readData.size)
                    System.arraycopy(readData, 0, data, blockIndex * blockSize, blockSize)
                }
                blockIndex += step
            }
            Log.d(LOG_ID, "Got NFC tag data")
        } catch (e: Exception) {
            Log.i(LOG_ID, e.toString())
            return false
        } finally {
            try {
                nfcvTag.close()
            } catch (e: Exception) {
                Log.e(LOG_ID, "Error closing tag!")
            }
        }
        Log.d(LOG_ID, "Tag data reader exiting")
        Log.d(LOG_ID, Arrays.toString(data))
        return true
    }

    private fun updateNfcStatus(setStatus: Boolean = false) : Boolean {
        if (!setStatus && (mNfcAdapter == null || mNfcAdapter!!.isEnabled == isNfcOn))
            return isNfcOn
        if (mNfcAdapter == null) {
            nfcStatus = context.getString(R.string.no_nfc)
            isNfcOn = false
        } else if (!mNfcAdapter!!.isEnabled) {
            nfcStatus = context.getString(R.string.nfc_disable)
            isNfcOn = false
        } else {
            nfcStatus = context.getString(R.string.ready_to_scan)
            isNfcOn = true
        }
        return isNfcOn
    }
}