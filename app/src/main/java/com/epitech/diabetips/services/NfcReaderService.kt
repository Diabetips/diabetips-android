package com.epitech.diabetips.services

import android.app.Activity
import android.app.PendingIntent
import android.content.Context
import android.content.Context.VIBRATOR_SERVICE
import android.content.Intent
import android.content.IntentFilter
import android.nfc.NfcAdapter
import android.nfc.Tag
import android.nfc.tech.NfcV
import android.os.AsyncTask
import android.os.Vibrator
import android.util.Log
import android.widget.TextView
import com.epitech.diabetips.freestylelibre.GlucoseData
import com.epitech.diabetips.freestylelibre.RawTagData
import com.epitech.diabetips.freestylelibre.SensorData
import java.io.*
import java.util.*
import kotlin.experimental.and

public var NFC_USE_MULTI_BLOCK_READ = true
var PENDING_INTENT_TECH_DISCOVERED = 1;

class NfcReaderService(var context: Context, myIntent: Intent) {

    val MIME_TEXT_PLAIN = "text/plain"

    private var mNfcAdapter: NfcAdapter? = null


    private val lectura: String? = null
    private var buffer: kotlin.String? = null
    private val currentGlucose = 0f
    private val tvResult: TextView? = null
    var numHistoryValues = 32
    var historyIntervalInMinutes = 15
    var numTrendValues = 16
    public var minSensorAgeInMinutes: Long =
        60 // data generated by the sensor in the first 60 minutes is not correct

    private var data: ByteArray = ByteArray(360)


    init {
        mNfcAdapter = NfcAdapter.getDefaultAdapter(context)
        if (mNfcAdapter == null) {
            throw IOException("This device doesn't support NFC.")
        }
        if (!mNfcAdapter!!.isEnabled) {
            throw IOException("NFC is disabled.")
        }
        handleIntent(myIntent)
        var glucoseDatas = ArrayList<GlucoseData>()
        try {
            val fos: FileOutputStream = context.applicationContext.openFileOutput(
                "glucose",
                Context.MODE_PRIVATE
            )
            fos.close()
            val fis: FileInputStream = context.applicationContext.openFileInput("glucose")
            val ois = ObjectInputStream(fis)
            glucoseDatas = ois.readObject() as ArrayList<GlucoseData>
            ois.close()
            fis.close()
        } catch (ioe: IOException) {
            ioe.printStackTrace()
        } catch (c: ClassNotFoundException) {
            c.printStackTrace()
        }
        Log.d("Saved data", """$glucoseDatas""".trimIndent())
        if (glucoseDatas.size > 1)
            Log.d("Saved Sensor age", """${glucoseDatas[0].ageInSensorMinutes}""".trimIndent())
    }

    fun onResume() {
        setupForegroundDispatch(context as Activity, mNfcAdapter)
    }

    fun onPause() {
        stopForegroundDispatch(context as Activity, mNfcAdapter)
    }

    fun onNewIntent(intent: Intent?) {
        /**
         * This method gets called, when a new Intent gets associated with the current activity instance.
         * Instead of creating a new activity, onNewIntent will be called. For more information have a look
         * at the documentation.
         *
         * In our case this method gets called, when the user attaches a Tag to the device.
         */
        Log.d("NfcReaderDiabetips", "NEW INTENT FOUND")
        if (intent != null) {
            handleIntent(intent)
        } else {
            Log.d("NfcReaderDiabetips", "No Intent found")
        }
    }

    private fun handleIntent(intent: Intent) {
        val action = intent.action
        Log.d("diabetips", "Action FOUND ! ! !")
        if (NfcAdapter.ACTION_TECH_DISCOVERED == action) {
            Log.d("diabetips", "NfcAdapter.ACTION_TECH_DISCOVERED")
            // In case we would still use the Tech Discovered Intent
            val tag =
                intent.getParcelableExtra<Tag>(NfcAdapter.EXTRA_TAG)
            val techList = tag.techList
            val searchedTech = NfcV::class.java.name
            NfcVReaderTask(context).execute(tag)
        }
    }

    /**
     * @param activity The corresponding [Activity] requesting the foreground dispatch.
     * @param adapter The [NfcAdapter] used for the foreground dispatch.
     */
    fun setupForegroundDispatch(activity: Activity, adapter: NfcAdapter?) {
//        val intent = Intent(activity.applicationContext, activity.javaClass)
//        intent.flags = Intent.FLAG_ACTIVITY_SINGLE_TOP
//        val pendingIntent =
//            PendingIntent.getActivity(activity.applicationContext, 0, intent, 0)
//        val filters = arrayOfNulls<IntentFilter>(1)
//        val techList =
//            arrayOf<Array<String>>()
//
//        // Notice that this is the same filter as in our manifest.
//        filters[0] = IntentFilter()
//        filters[0]!!.addAction(NfcAdapter.ACTION_NDEF_DISCOVERED)
//        filters[0]!!.addCategory(Intent.CATEGORY_DEFAULT)
//        filters[0]!!.addDataType("*/*")
//        adapter!!.enableForegroundDispatch(activity, pendingIntent, filters, techList)
        val pi: PendingIntent = activity.createPendingResult(PENDING_INTENT_TECH_DISCOVERED, Intent(), 0)
        if (pi != null) {
            try {
                mNfcAdapter!!.enableForegroundDispatch(
                    activity,
                    pi,
                    arrayOf(IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED)),
                    arrayOf(arrayOf("android.nfc.tech.NfcV"))
                )
            } catch (e: NullPointerException) {
                // Drop NullPointerException
            }
        }

        Log.d("TOTO", "SETUP ForegroundDispatch")
    }

    /**
     * @param activity The corresponding {BaseActivity} requesting to stop the foreground dispatch.
     * @param adapter The [NfcAdapter] used for the foreground dispatch.
     */
    fun stopForegroundDispatch(activity: Activity?, adapter: NfcAdapter?) {
        adapter!!.disableForegroundDispatch(activity)
    }

    protected val hexArray = "0123456789ABCDEF".toCharArray()
    fun bytesToHex(bytes: ByteArray): String? {
        val hexChars = CharArray(bytes.size * 2)
        for (j in bytes.indices) {
            val v: Int = (bytes[j] and 0xFF.toByte()).toInt()
            hexChars[j * 2] = hexArray[v ushr 4]
            hexChars[j * 2 + 1] = hexArray[v and 0x0F]
        }
        return String(hexChars)
    }

    private val LOG_ID = "OpenLibre::" + NfcVReaderTask::class.java.simpleName
    private val nfcReadTimeout: Long = 1000 // [ms]

    private var sensorTagId: String? = null

    /**
     *
     * Background task for reading the data. Do not block the UI thread while reading.
     *
     */
    private inner class NfcVReaderTask(var context: Context) : AsyncTask<Tag?, Void?, String?>() {

        override fun onPostExecute(result: String?) {
            val vibrator = context.getSystemService(VIBRATOR_SERVICE) as Vibrator
            vibrator.vibrate(1000)
            //Abbott.this.finish();
        }

        fun bytesToHexString(src: ByteArray?): String {
            val builder = StringBuilder("")
            if (src == null || src.size <= 0) {
                return ""
            }
            val buffer = CharArray(2)
            for (b in src) {
                buffer[0] =
                    Character.forDigit(((b.toInt() ushr 4).toByte() and 0x0F.toByte()).toInt(), 16)
                buffer[1] = Character.forDigit((b and 0x0F.toByte()).toInt(), 16)
                builder.append(buffer)
            }
            return builder.toString()
        }

        override fun doInBackground(vararg params: Tag?): String? {
            val tag = params[0]
            val nfcvTag = NfcV.get(tag)
            Log.d("diabetips", "Enter NdefReaderTask: $nfcvTag")
            Log.d("diabetips", "Tag ID: " + tag!!.id)
            sensorTagId = bytesToHexString(tag.id)
            readNfcTag(tag)
            val raw = RawTagData(sensorTagId, data)
            Log.d("diabetips", "Date : " + raw.date)
            Log.d("diabetips", "Tag Id : " + raw.tagId)
            Log.d("diabetips", "Sensor age : " + raw.sensorAgeInMinutes)
            Log.d(
                "diabetips",
                "TimeZone Offset : " + raw.timezoneOffsetInMinutes / 60
            )
            val indexHistory = raw.getIndexHistory()
            val glucoseLevels = ArrayList<Int>()
            val ageInSensorMinutesList = ArrayList<Int>()
            val mostRecentHistoryAgeInMinutes: Int =
                3 + (raw.sensorAgeInMinutes - 3) % historyIntervalInMinutes
            val sensor = SensorData(raw)
            val glucoseDatas = ArrayList<GlucoseData>()
            // read history values from ring buffer, starting at indexHistory (bytes 124-315)
            for (counter in 0 until numHistoryValues) {
                val index: Int = (indexHistory + counter) % numHistoryValues
                val glucoseLevelRaw = raw.getHistoryValue(index)
                // skip zero values if the sensor has not filled the ring buffer yet completely
                if (glucoseLevelRaw > 0) {
                    val dataAgeInMinutes: Int =
                        mostRecentHistoryAgeInMinutes + (numHistoryValues - (counter + 1)) * historyIntervalInMinutes
                    val ageInSensorMinutes = raw.sensorAgeInMinutes - dataAgeInMinutes

                    // skip the first hour of sensor data as it is faulty
                    if (ageInSensorMinutes > minSensorAgeInMinutes) {
                        glucoseLevels.add(glucoseLevelRaw)
                        ageInSensorMinutesList.add(ageInSensorMinutes)
                        val glucoseData = GlucoseData(
                            sensor,
                            raw.sensorAgeInMinutes,
                            raw.timezoneOffsetInMinutes,
                            glucoseLevelRaw,
                            true,
                            ageInSensorMinutes.toLong()
                        )
                        glucoseDatas.add(glucoseData)
                    }
                }
            }
            try {
                val fos: FileOutputStream = context.applicationContext.openFileOutput(
                    "glucose",
                    Context.MODE_PRIVATE
                )
                val oos = ObjectOutputStream(fos)
                oos.writeObject(glucoseDatas)
                oos.close()
                fos.close()
            } catch (ioe: IOException) {
                ioe.printStackTrace()
            }
//            Log.d("Saved data", """$glucoseDatas""".trimIndent())
//            Log.d("Saved Sensor age", """${glucoseDatas[0].ageInSensorMinutes}""".trimIndent())
            Log.d("diabetips", "Glucose values : $glucoseLevels")
            Log.d("diabetips", "Sensor Ages    : $ageInSensorMinutesList")
            return null
        }
    }

    private fun readNfcTag(tag: Tag): Boolean {
        val nfcvTag = NfcV.get(tag)
        Log.d(LOG_ID, "Attempting to read tag data")
        try {
            nfcvTag.connect()
            val uid = tag.id
            val step = if (NFC_USE_MULTI_BLOCK_READ) 3 else 1
            val blockSize = 8
            var blockIndex = 0
            while (blockIndex <= 40) {
                var cmd: ByteArray
                if (NFC_USE_MULTI_BLOCK_READ) {
                    cmd = byteArrayOf(
                        0x02,
                        0x23,
                        blockIndex.toByte(),
                        0x02
                    ) // multi-block read 3 blocks
                } else {
                    cmd = byteArrayOf(
                        0x60,
                        0x20,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        blockIndex.toByte(),
                        0
                    )
                    System.arraycopy(uid, 0, cmd, 2, 8)
                }
                var readData: ByteArray
                val startReadingTime = System.currentTimeMillis()
                while (true) {
                    try {
                        readData = nfcvTag.transceive(cmd)
                        break
                    } catch (e: IOException) {
                        if (System.currentTimeMillis() > startReadingTime + nfcReadTimeout) {
                            Log.e(LOG_ID, "tag read timeout")
                            return false
                        }
                    }
                }
                if (NFC_USE_MULTI_BLOCK_READ) {
                    System.arraycopy(
                        readData,
                        1,
                        data,
                        blockIndex * blockSize,
                        readData.size - 1
                    )
                } else {
                    readData = Arrays.copyOfRange(readData, 2, readData.size)
                    System.arraycopy(readData, 0, data, blockIndex * blockSize, blockSize)
                }
                blockIndex += step
            }
            Log.d(LOG_ID, "Got NFC tag data")
        } catch (e: Exception) {
            Log.i(LOG_ID, e.toString())
            return false
        } finally {
            try {
                nfcvTag.close()
            } catch (e: Exception) {
                Log.e(LOG_ID, "Error closing tag!")
            }
        }
        Log.d(LOG_ID, "Tag data reader exiting")
        Log.d(LOG_ID, Arrays.toString(data))
        return true
    }
}