package com.epitech.diabetips.freestylelibre;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.nfc.NfcAdapter;
import android.nfc.Tag;
import android.nfc.tech.NfcV;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Vibrator;
import android.util.Log;
import android.widget.TextView;
import android.widget.Toast;

import com.epitech.diabetips.R;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Arrays;

/**
 *
 * Activity for reading data from FreeStyleLibre Tag
 *
 */
public class Abbott {

//    public static final String MIME_TEXT_PLAIN = "text/plain";
//
//    private NfcAdapter mNfcAdapter;
//
//    private String lectura, buffer;
//    private float currentGlucose = 0f;
//    private TextView tvResult;
//    public static final int numHistoryValues = 32;
//    public static final int historyIntervalInMinutes = 15;
//    public static final int numTrendValues = 16;
//    public static final long minSensorAgeInMinutes = 60; // data generated by the sensor in the first 60 minutes is not correct
//
//    @Override
//    protected void onCreate(Bundle savedInstanceState) {
//        data = new byte[360];
//
//        mNfcAdapter = NfcAdapter.getDefaultAdapter(this);
//
//        if (mNfcAdapter == null) {
//            // Stop here, we definitely need NFC
//            Toast.makeText(this, "This device doesn't support NFC.", Toast.LENGTH_LONG).show();
//            finish();
//            return;
//        }
//
//        if (!mNfcAdapter.isEnabled()) {
//            Toast.makeText(this, "NFC is disabled.", Toast.LENGTH_LONG).show();
//        }
//
//        handleIntent(getIntent());
//
//        ArrayList<GlucoseData> glucoseDatas = new ArrayList<GlucoseData>();
//
//        try
//        {
//            FileInputStream fis =  getApplicationContext().openFileInput("glucose");
//            ObjectInputStream ois = new ObjectInputStream(fis);
//
//            glucoseDatas = (ArrayList) ois.readObject();
//
//            ois.close();
//            fis.close();
//        }
//        catch (IOException ioe)
//        {
//            ioe.printStackTrace();
//            return;
//        }
//        catch (ClassNotFoundException c)
//        {
//            System.out.println("Class not found");
//            c.printStackTrace();
//            return;
//        }
//        Log.d("Saved data", "\n" + glucoseDatas.toString());
//        Log.d("Saved Sensor age", "\n" + glucoseDatas.get(0).getAgeInSensorMinutes());
//    }
//
//    @Override
//    protected void onResume() {
//        super.onResume();
//
//        /**
//         * It's important, that the activity is in the foreground (resumed). Otherwise
//         * an IllegalStateException is thrown.
//         */
//        setupForegroundDispatch(this, mNfcAdapter);
//    }
//
//    @Override
//    protected void onPause() {
//        /**
//         * Call this before onPause, otherwise an IllegalArgumentException is thrown as well.
//         */
//        stopForegroundDispatch(this, mNfcAdapter);
//
//        super.onPause();
//    }
//
//    @Override
//    protected void onNewIntent(Intent intent) {
//        /**
//         * This method gets called, when a new Intent gets associated with the current activity instance.
//         * Instead of creating a new activity, onNewIntent will be called. For more information have a look
//         * at the documentation.
//         *
//         * In our case this method gets called, when the user attaches a Tag to the device.
//         */
//        handleIntent(intent);
//    }
//
//    private void handleIntent(Intent intent) {
//        String action = intent.getAction();
//        if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(action)) {
//
//            Log.d("diabetips", "NfcAdapter.ACTION_TECH_DISCOVERED");
//            // In case we would still use the Tech Discovered Intent
//            Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
//            String[] techList = tag.getTechList();
//            String searchedTech = NfcV.class.getName();
//            new NfcVReaderTask().execute(tag);
//
//        }
//    }
//
//    /**
//     * @param activity The corresponding {@link Activity} requesting the foreground dispatch.
//     * @param adapter The {@link NfcAdapter} used for the foreground dispatch.
//     */
//    public static void setupForegroundDispatch(final Activity activity, NfcAdapter adapter) {
//        final Intent intent = new Intent(activity.getApplicationContext(), activity.getClass());
//        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
//
//        final PendingIntent pendingIntent = PendingIntent.getActivity(activity.getApplicationContext(), 0, intent, 0);
//
//        IntentFilter[] filters = new IntentFilter[1];
//        String[][] techList = new String[][]{};
//
//        // Notice that this is the same filter as in our manifest.
//        filters[0] = new IntentFilter();
//        filters[0].addAction(NfcAdapter.ACTION_NDEF_DISCOVERED);
//        filters[0].addCategory(Intent.CATEGORY_DEFAULT);
//
//        adapter.enableForegroundDispatch(activity, pendingIntent, filters, techList);
//    }
//
//    /**
//     * @param activity The corresponding {BaseActivity} requesting to stop the foreground dispatch.
//     * @param adapter The {@link NfcAdapter} used for the foreground dispatch.
//     */
//    public static void stopForegroundDispatch(final Activity activity, NfcAdapter adapter) {
//        adapter.disableForegroundDispatch(activity);
//    }
//
//    final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();
//    public static String bytesToHex(byte[] bytes) {
//        char[] hexChars = new char[bytes.length * 2];
//        for ( int j = 0; j < bytes.length; j++ ) {
//            int v = bytes[j] & 0xFF;
//            hexChars[j * 2] = hexArray[v >>> 4];
//            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
//        }
//        return new String(hexChars);
//    }
//
//    /**
//     *
//     * Background task for reading the data. Do not block the UI thread while reading.
//     *
//     */
//    private class NfcVReaderTask extends AsyncTask<Tag, Void, String> {
//
//        @Override
//        protected void onPostExecute(String result) {
//            Vibrator vibrator = (Vibrator)getSystemService(VIBRATOR_SERVICE);
//            vibrator.vibrate(1000);
//            //Abbott.this.finish();
//        }
//
//        public String bytesToHexString(byte[] src) {
//            StringBuilder builder = new StringBuilder("");
//            if (src == null || src.length <= 0) {
//                return "";
//            }
//
//            char[] buffer = new char[2];
//            for (byte b : src) {
//                buffer[0] = Character.forDigit((b >>> 4) & 0x0F, 16);
//                buffer[1] = Character.forDigit(b & 0x0F, 16);
//                builder.append(buffer);
//            }
//
//            return builder.toString();
//        }
//
//        @Override
//        protected String doInBackground(Tag... params) {
//            Tag tag = params[0];
//
//            NfcV nfcvTag = NfcV.get(tag);
//            Log.d("diabetips", "Enter NdefReaderTask: " + nfcvTag.toString());
//
//            Log.d("diabetips", "Tag ID: "+tag.getId());
//            sensorTagId = bytesToHexString(tag.getId());
//            readNfcTag(tag);
//
//            RawTagData raw = new RawTagData(sensorTagId, data);
//
//            Log.d("diabetips", "Date : " + raw.getDate());
//            Log.d("diabetips", "Tag Id : " + raw.getTagId());
//            Log.d("diabetips", "Sensor age : " + raw.getSensorAgeInMinutes());
//            Log.d("diabetips", "TimeZone Offset : " + raw.getTimezoneOffsetInMinutes() / 60);
//
//            int indexHistory = raw.getIndexHistory();
//
//            ArrayList<Integer> glucoseLevels = new ArrayList<>();
//            ArrayList<Integer> ageInSensorMinutesList = new ArrayList<>();
//            int mostRecentHistoryAgeInMinutes = 3 + (raw.getSensorAgeInMinutes() - 3) % historyIntervalInMinutes;
//            SensorData sensor = new SensorData(raw);
//            ArrayList<GlucoseData> glucoseDatas = new ArrayList<>();
//            // read history values from ring buffer, starting at indexHistory (bytes 124-315)
//            for (int counter = 0; counter < numHistoryValues; counter++) {
//                int index = (indexHistory + counter) % numHistoryValues;
//
//                int glucoseLevelRaw = raw.getHistoryValue(index);
//                // skip zero values if the sensor has not filled the ring buffer yet completely
//                if (glucoseLevelRaw > 0) {
//                    int dataAgeInMinutes = mostRecentHistoryAgeInMinutes + (numHistoryValues - (counter + 1)) * historyIntervalInMinutes;
//                    int ageInSensorMinutes = raw.getSensorAgeInMinutes() - dataAgeInMinutes;
//
//                    // skip the first hour of sensor data as it is faulty
//                    if (ageInSensorMinutes > minSensorAgeInMinutes) {
//                        glucoseLevels.add(glucoseLevelRaw);
//                        ageInSensorMinutesList.add(ageInSensorMinutes);
//                        GlucoseData glucoseData = new GlucoseData(sensor, raw.getSensorAgeInMinutes(), raw.getTimezoneOffsetInMinutes(), glucoseLevelRaw, true, ageInSensorMinutes);
//                        glucoseDatas.add(glucoseData);
//                    }
//                }
//            }
//
//            try
//            {
//                FileOutputStream fos = getApplicationContext().openFileOutput("glucose", Context.MODE_PRIVATE);
//                ObjectOutputStream oos = new ObjectOutputStream(fos);
//                oos.writeObject(glucoseDatas);
//                oos.close();
//                fos.close();
//            }
//            catch (IOException ioe) {
//                ioe.printStackTrace();
//            }
//            Log.d("Saved data", "\n" + glucoseDatas.toString());
//            Log.d("Saved Sensor age", "\n" + glucoseDatas.get(0).getAgeInSensorMinutes());
//            Log.d("diabetips", "Glucose values : " + glucoseLevels.toString());
//            Log.d("diabetips", "Sensor Ages    : " + ageInSensorMinutesList.toString());
//            return null;
//        }
//
//
//    }
//
//    public static boolean NFC_USE_MULTI_BLOCK_READ = true;
//    public static boolean GLUCOSE_UNIT_IS_MMOL = false;
//
//    private static final String LOG_ID = "OpenLibre::" + NfcVReaderTask.class.getSimpleName();
//    private static final long nfcReadTimeout = 1000; // [ms]
//    private String sensorTagId;
//    private byte[] data;
//
//    private boolean readNfcTag(Tag tag) {
//        NfcV nfcvTag = NfcV.get(tag);
//        Log.d(LOG_ID, "Attempting to read tag data");
//        try {
//            nfcvTag.connect();
//            final byte[] uid = tag.getId();
//            final int step = NFC_USE_MULTI_BLOCK_READ ? 3 : 1;
//            final int blockSize = 8;
//
//            for (int blockIndex = 0; blockIndex <= 40; blockIndex += step) {
//                byte[] cmd;
//                if (NFC_USE_MULTI_BLOCK_READ) {
//                    cmd = new byte[]{0x02, 0x23, (byte) blockIndex, 0x02}; // multi-block read 3 blocks
//                } else {
//                    cmd = new byte[]{0x60, 0x20, 0, 0, 0, 0, 0, 0, 0, 0, (byte) blockIndex, 0};
//                    System.arraycopy(uid, 0, cmd, 2, 8);
//                }
//
//                byte[] readData;
//                Long startReadingTime = System.currentTimeMillis();
//                while (true) {
//                    try {
//                        readData = nfcvTag.transceive(cmd);
//                        break;
//                    } catch (IOException e) {
//                        if ((System.currentTimeMillis() > startReadingTime + nfcReadTimeout)) {
//                            Log.e(LOG_ID, "tag read timeout");
//                            return false;
//                        }
//                    }
//                }
//
//                if (NFC_USE_MULTI_BLOCK_READ) {
//                    System.arraycopy(readData, 1, data, blockIndex * blockSize, readData.length - 1);
//                } else {
//                    readData = Arrays.copyOfRange(readData, 2, readData.length);
//                    System.arraycopy(readData, 0, data, blockIndex * blockSize, blockSize);
//                }
//            }
//            Log.d(LOG_ID, "Got NFC tag data");
//
//        } catch (Exception e) {
//
//            Log.i(LOG_ID, e.toString());
//            return false;
//
//        } finally {
//            try {
//                nfcvTag.close();
//            } catch (Exception e) {
//                Log.e(LOG_ID, "Error closing tag!");
//            }
//        }
//        Log.d(LOG_ID, "Tag data reader exiting");
//        Log.d(LOG_ID, Arrays.toString(data));
//        return true;
//    }

}


